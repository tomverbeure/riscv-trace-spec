\chapter{Introduction}
\label{sec:intro}

In complex systems understanding program behavior is not easy.
Unsurprisingly in such systems, software sometimes does not behave as
expected. This may be due to a number of factors, for example,
interactions with other cores, software, peripherals, realtime
events, poor implementations or some combination of all of the above.

It is not always possible to use a debugger to observe behavior of a
running system as this is intrusive.  Providing visibility of program
execution is important.  This needs to be done without swamping the
system with vast amounts of data.

One method of achieving this is via a Processor Branch Trace.

This works by tracking execution from a known start address and sending
messages about the address deltas taken by the program. These deltas are
typically introduced by jump, call, return and branch type instructions,
although interrupts and exceptions are also types of deltas.

Conceptually, the system has one or more of the following fundamental components:

\begin{itemize}
  \item
    A CPU with an instruction trace interface that outputs all relevant
    information to successfully create a processor branch trace and more.
    This is a high bandwidth interface: in most implementations, it will supply
    a large amount of data (instruction address, instruction type, context information, ...)
    for each CPU execution clock cycle.
  \item
    A hardware encoder that takes in the CPU instruction trace and compresses
    it into lower bandwidth trace packets.
  \item
    A transmission channel that to transmit or a memory to store
    these trace packets.
  \item
    A decoder, usually software on an external PC, that takes in the trace
    packets and, with knowledge of the program binary that's running the
    originating CPU, reconstructs the program flow. This decoding step can
    be done off-line or in real-time while the CPU is executing.
\end{itemize}

In RISC-V, all instructions are executed unconditionally or at least
their execution can be determined based on the execution binary. The
instructions between the deltas can all assumed to be executed
sequentially. Because of this, there is no need to report sequential 
instructions in the trace, only whether the branches were taken or not
and the address of taken indirect branches or jumps. If the program
counter is changed by an amount that cannot be determined from the
execution binary, the trace decoder needs to be given the destination
address (i.e. the address of the next valid instruction).  Examples of
this are indirect branches or jumps, where the next instruction
address is determined by the contents of a register rather than a
constant embedded in the source code.

Interrupts generally occur asynchronously to the program's execution
rather than intentionally as a result of a specific instruction or
event.  Exceptions can be thought of in the same way, even though they
can be typically linked back to a specific instruction address.  The
decoder generally does not know where an interrupt occurs in the
instruction sequence, so the trace encoder must report the address
where normal program flow ceased, as well as give an indication of the
asynchronous destination which may be as simple as reporting the
exception type.  When an interrupt or exception occurs, or the
processor is halted, the final instruction executed beforehand must be
included in the trace.

The primary goal of this document is to specify the ingress interface, the
instruction trace interface between a RISC-V CPU and an encoder. It
establishes a standard for CPU designers to follow such that they can interface
with encoders from various IP providers.

In addition, this document also details an example of a compressed branch trace
algorithm and a packet format to encapsulate the compressed branch trace
information.  However, this is not a normative part of the specficiation.

\subsection{Nomenclature}

In the following sections items in \textbf{bold} are signals or
attributes within a packet.

Items in \textit {italics} refer to parameters either built into the
hardware or configurable hardware values.

A decoder is a piece of software that takes the packets emitted by the
encoder and is able to reconstruct the execution flow of the code
executed in the RISC-V core.

RISC-V has the following definitions:
\begin{itemize}
  \item
    \textbf{Exception}: an unusual condition occurring at run time associated with an instruction in the current RISC-V hart
  \item
    \textbf{Interrupt}: an external asynchronous event that may cause a RISC-V hart to experience an unexpected transfer of control
  \item
    \textbf{Trap}: the transfer of control to a trap handler caused by either an exception or an interrupt
\end{itemize}
So, not all exceptions and interrupts cause traps. Most notably, floating point exceptions and disabled interrupts do not trap.

If an exception or interrupt doesn't trap, the program counter does not
change. So, there is no need to trace all exceptions/interrupts, just
traps.

In this document interrupts and exceptions traced are only those that cause traps to be taken.
